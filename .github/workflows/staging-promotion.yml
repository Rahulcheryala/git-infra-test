name: Staging Promotion
run-name: PR from develop to staging by @${{ github.actor }}

on:
  workflow_dispatch:
    inputs:
      create_pr:
        description: "Create PR from develop to staging"
        required: true
        default: true
        type: boolean

permissions:
  contents: write
  pull-requests: write

jobs:
  # Job 1: Analyze Develop Commits
  commit-analysis:
    name: Commit Analysis
    runs-on: ubuntu-latest
    outputs:
      promotion_needed: ${{ steps.analyze.outputs.promotion_needed }}
      commit_count: ${{ steps.analyze.outputs.commit_count }}
      promotion_id: ${{ steps.analyze.outputs.promotion_id }}
      timestamp: ${{ steps.analyze.outputs.timestamp }}
      new_commits: ${{ steps.analyze.outputs.new_commits }}
      existing_pr: ${{ steps.analyze.outputs.existing_pr }}
      groups: ${{ steps.analyze.outputs.groups }}
      grouped_commits_md: ${{ steps.analyze.outputs.grouped_commits_md }}
      feature_prs_md: ${{ steps.analyze.outputs.feature_prs_md }}

    steps:
      - name: Checkout develop
        uses: actions/checkout@v4
        with:
          ref: develop
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Fetch staging branch
        run: |
          echo "üì• Fetching staging branch for comparison..."
          git fetch origin staging:origin-staging
          echo "‚úÖ Staging branch fetched successfully"

      - name: Analyze develop commits for staging promotion
        id: analyze
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          # Use IST (Asia/Kolkata) for all timestamps in this job
          IST_TIMESTAMP="$(TZ=Asia/Kolkata date +'%d/%m/%Y %H:%M:%S %Z')"

          echo "üì• Ensuring origin/staging is up to date..."
          git fetch origin staging:origin-staging
          echo ""

          echo "üîç Quick tree diff (develop vs staging)..."
          if git diff --quiet origin-staging..HEAD; then
            echo "‚úÖ Develop and staging have identical content"
            {
              echo "promotion_needed=false"
              echo "commit_count=0"
              echo "promotion_id="
              echo "timestamp=$IST_TIMESTAMP"
              echo "existing_pr="
              echo "new_commits="
            } >> "$GITHUB_OUTPUT"
            exit 0
          fi
          echo ""

          echo "üîç Find the last point where staging was merged back into develop..."
          # Strategy: scan recent merge commits on develop; pick the most recent
          # merge whose one parent is reachable from origin/staging.
          LAST_SYNC_SHA=""
          for commit in $(git rev-list --merges HEAD | head -200); do
            p1=$(git rev-parse "$commit^1")
            p2=$(git rev-parse "$commit^2" 2>/dev/null || true)
            if git merge-base --is-ancestor "$p1" origin/staging || \
               { [ -n "$p2" ] && git merge-base --is-ancestor "$p2" origin/staging; }; then
              LAST_SYNC_SHA="$commit"
              msg=$(git log -1 --format=%s "$commit")
              echo "‚ÑπÔ∏è Found last staging‚Üídevelop sync at: ${commit:0:9}"
              echo "   Parents: ${p1:0:9} ${p2:0:9}"
              echo "   Subject: $msg"
              break
            fi
          done
          echo ""

          # If no explicit merge found, use git merge-base as fallback
          if [ -z "$LAST_SYNC_SHA" ]; then
            echo "üîé No staging‚Üídevelop merge commit found"
            echo "   Trying merge-base between develop and staging..."
            if LAST_SYNC_SHA=$(git merge-base origin-staging HEAD 2>/dev/null); then
              echo "‚ÑπÔ∏è Using merge-base as starting point: ${LAST_SYNC_SHA:0:9}"
            else
              echo "‚ö†Ô∏è  No common ancestor found between develop and staging"
              echo "   This may happen if history was rewritten or is a shallow clone"
              echo "   Using all commits in develop as potentially new"
              LAST_SYNC_SHA=""
            fi
          fi

          # Determine the range to analyze
          if [ -n "$LAST_SYNC_SHA" ]; then
            LOG_RANGE="${LAST_SYNC_SHA}..HEAD"
          else
            # No sync point found - analyze all commits in develop
            LOG_RANGE="HEAD"
          fi

          # Get all commits to analyze (oldest first)
          if [ -n "$LAST_SYNC_SHA" ]; then
            mapfile -t SHAS_IN_RANGE < <(git rev-list --no-merges --reverse "$LOG_RANGE" || true)
          else
            mapfile -t SHAS_IN_RANGE < <(git rev-list --no-merges --reverse HEAD || true)
          fi

          if [ "${#SHAS_IN_RANGE[@]}" -eq 0 ]; then
            echo "‚ÑπÔ∏è No commits found since last sync with staging"
            {
              echo "promotion_needed=false"
              echo "commit_count=0"
              echo "promotion_id="
              echo "timestamp=$IST_TIMESTAMP"
              echo "existing_pr="
              echo "new_commits="
            } >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Build commits list for PR body from SHAs
          NEW_COMMITS=""
          for sha in "${SHAS_IN_RANGE[@]}"; do
            subj="$(git log -n1 --format=%s "$sha")"
            NEW_COMMITS+="${sha:0:7} ${subj}"$'\n'
          done

          echo "üîé Check if an open develop‚Üístaging PR exists..."
          EXISTING_PR="$(gh pr list --base staging --head develop --state open --json number --jq '.[0].number' || true)"
          EXISTING_ID=""
          if [ -n "${EXISTING_PR:-}" ] && [ "${EXISTING_PR}" != "null" ]; then
            echo "‚ÑπÔ∏è Open PR detected: #$EXISTING_PR"
            PR_TEXT="$(gh pr view "$EXISTING_PR" --json title,body --jq '[.title,.body]|join("\n")' || true)"
            # Extract existing Promotion ID if present
            EXISTING_ID="$(printf "%s" "$PR_TEXT" | sed -nE 's/.*Promotion ID[^`]*`([^`]+)`.*/\1/p' | head -n1 || true)"
          fi

          TIMESTAMP="$IST_TIMESTAMP"
          if [ -n "${EXISTING_ID:-}" ]; then
            PROMOTION_ID="$EXISTING_ID"
            echo "üîÅ Reusing existing PR promotion ID: $PROMOTION_ID"
          else
            PROMOTION_ID="staging_$(TZ=Asia/Kolkata date +'%d-%m-%Y_%H.%M.%S')"
            echo "üÜï Generated new promotion ID: $PROMOTION_ID"
          fi
          echo ""

          COMMIT_COUNT="${#SHAS_IN_RANGE[@]}"

          # Group by feature head ref using GitHub API (first associated PR)
          declare -A GROUP_TO_SHAS
          declare -A GROUP_TO_PR

          for sha in "${SHAS_IN_RANGE[@]}"; do
            pr_json="$(gh api -H "Accept: application/vnd.github+json" repos/${GITHUB_REPOSITORY}/commits/${sha}/pulls --jq '.[0] | {url: .html_url, head: .head.ref}' 2>/dev/null || true)"
            group=""
            pr_url=""
            if [ -n "$pr_json" ]; then
              group="$(printf '%s' "$pr_json" | jq -r '.head // empty')"
              pr_url="$(printf '%s' "$pr_json" | jq -r '.url // empty')"
            fi
            if [[ -z "$group" || ! "$group" =~ ^feature/ ]]; then
              group="misc/ungrouped"
            fi
            if [ -n "${GROUP_TO_SHAS[$group]:-}" ]; then
              GROUP_TO_SHAS[$group]="${GROUP_TO_SHAS[$group]} $sha"
            else
              GROUP_TO_SHAS[$group]="$sha"
            fi
            if [ -n "$pr_url" ] && [ -z "${GROUP_TO_PR[$group]:-}" ]; then
              GROUP_TO_PR[$group]="$pr_url"
            fi
          done

          # Build markdown fragments without top-level headers; headers will be
          # added only where rendered (logs/PR body) to avoid duplication.
          GROUPED_MD=""
          FEATURE_PRS_MD=""
          GROUPS_LINES=""

          mapfile -t GROUP_NAMES < <(printf '%s\n' "${!GROUP_TO_SHAS[@]}" | sort)
          for group in "${GROUP_NAMES[@]}"; do
            shas_line="${GROUP_TO_SHAS[$group]}"
            GROUPS_LINES+="$group|$shas_line"$'\n'
            GROUPED_MD+="#### $group"$'\n'
            pr_link="${GROUP_TO_PR[$group]:-}"
            if [ -n "$pr_link" ]; then
              FEATURE_PRS_MD+="- $group: $pr_link"$'\n'
              GROUPED_MD+="PR: $pr_link"$'\n'
            fi
            for s in $shas_line; do
              subj="$(git log -n1 --format=%s "$s")"
              GROUPED_MD+="- ${s:0:7} ${subj}"$'\n'
            done
            GROUPED_MD+=$'\n'
          done

          echo "üìù Analyzing commits in range: $LOG_RANGE"
          echo "üìä Analysis Results:"
          echo "  ‚Ä¢ Commits to promote: $COMMIT_COUNT"
          echo "  ‚Ä¢ Promotion ID: $PROMOTION_ID"
          echo "  ‚Ä¢ Timestamp: $TIMESTAMP"
          echo ""

          echo "üìù Commits to be promoted to staging (grouped):"
          echo "üß© Commits Grouped by Feature"
          printf "%s\n" "$GROUPED_MD"
          echo ""

          {
            echo "promotion_needed=true"
            echo "commit_count=$COMMIT_COUNT"
            echo "promotion_id=$PROMOTION_ID"
            echo "timestamp=$TIMESTAMP"
            echo "existing_pr=${EXISTING_PR:-}"
          } >> "$GITHUB_OUTPUT"
          {
            echo "new_commits<<EOF"
            printf "%s\n" "$NEW_COMMITS"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
          {
            echo "groups<<EOF"
            printf "%s\n" "$GROUPS_LINES"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
          {
            echo "grouped_commits_md<<EOF"
            printf "%s\n" "$GROUPED_MD"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
          {
            echo "feature_prs_md<<EOF"
            printf "%s\n" "$FEATURE_PRS_MD"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

  # Job 2: Create Staging Promotion PR
  create-pr:
    name: Create Staging PR
    runs-on: ubuntu-latest
    needs: commit-analysis
    if: needs.commit-analysis.outputs.promotion_needed == 'true' && inputs.create_pr
    outputs:
      pr_number: ${{ steps.create_pr.outputs.pr_number }}
      pr_url: ${{ steps.create_pr.outputs.pr_url }}

    steps:
      - name: Checkout staging
        uses: actions/checkout@v4
        with:
          ref: staging
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Ensure full fetch
        run: |
          git fetch --all --prune
          git fetch origin develop:origin-develop --prune
          # Also fetch the promoter branch if it exists
          git fetch origin staging-promoter:origin-staging-promoter || true

      - name: Detect existing PR for promoter branch
        id: check_existing
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          REPO="${GITHUB_REPOSITORY}"
          HEAD_BRANCH="staging-promoter"
          EXISTING_NUMBER="$(gh pr list --base staging --head "$HEAD_BRANCH" --state open --json number --jq '.[0].number' || true)"
          if [ -n "${EXISTING_NUMBER:-}" ] && [ "${EXISTING_NUMBER}" != "null" ]; then
            PR_NUMBER="$EXISTING_NUMBER"
            echo "exists=true" >> "$GITHUB_OUTPUT"
            echo "pr_number=$EXISTING_NUMBER" >> "$GITHUB_OUTPUT"
            echo "pr_url=https://github.com/${REPO}/pull/${EXISTING_NUMBER}" >> "$GITHUB_OUTPUT"
            echo "üîÅ Reusing PR #$PR_NUMBER and updating title/body..."
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Build promoter branch with grouped squash commits
        if: steps.check_existing.outputs.exists != 'true'
        id: build_temp_branch
        run: |
          set -euo pipefail

          PROMOTION_ID="${{ needs.commit-analysis.outputs.promotion_id }}"
          TEMP_BRANCH="staging-promoter"

          echo "üì¶ Creating promoter branch from staging: $TEMP_BRANCH"
          git checkout -B "$TEMP_BRANCH" origin/staging
          echo ""

          echo "üë§ Configuring git author for commits"
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          echo "üîÄ Applying grouped cherry-picks as squash commits"
          GROUPS_DATA='${{ needs.commit-analysis.outputs.groups }}'
          COMMITS_CREATED=0
          echo "$GROUPS_DATA" | while IFS='|' read -r group shas; do
            [ -z "$group" ] && continue
            [ -z "$shas" ] && continue
            echo "  ‚Ä¢ Group: $group"
            echo "    SHAs: $shas"
            echo ""

            # Cherry-pick commits without committing
            if git cherry-pick -n $shas; then
              # Check if there are any changes to commit
              if git diff --cached --quiet; then
                echo "    ‚ÑπÔ∏è No changes introduced (commits already in staging), skipping"
              else
                git commit -m "$group"
                echo "    ‚úÖ Created squash commit for $group"
                COMMITS_CREATED=$((COMMITS_CREATED + 1))
              fi
            else
              echo "    ‚ö†Ô∏è Cherry-pick failed, aborting"
              git cherry-pick --abort || true
              exit 1
            fi
          done
          echo ""
          echo ""

          # Check if promoter branch has any new commits compared to staging
          COMMITS_AHEAD=$(git rev-list --count origin/staging..HEAD)
          if [ "$COMMITS_AHEAD" -eq 0 ]; then
            echo "‚ö†Ô∏è No new commits to promote (all commits already in staging)"
            echo "‚ÑπÔ∏è Skipping promoter branch push"
            exit 0
          fi

          echo "üöÄ Pushing promoter branch ($COMMITS_AHEAD new commits)"
          git push -u origin "$TEMP_BRANCH" --force

          echo "temp_branch=$TEMP_BRANCH" >> "$GITHUB_OUTPUT"

      - name: Create or reuse PR from promoter branch to staging
        id: create_pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          REPO="${GITHUB_REPOSITORY}"

          TITLE="Staging Promotion: ${{ needs.commit-analysis.outputs.promotion_id }}"

          HEAD_BRANCH="staging-promoter"

          echo "üìù Ensuring PR base=staging head=${HEAD_BRANCH}"

          echo "üßæ Building PR body file"
          BODY_FILE=body.md
          {
            echo "## üöÄ Staging Promotion"
            echo ""
            echo "This PR promotes features from \`develop\` to \`staging\` for testing."
            echo ""
            echo "### üìã Promotion Information"
            echo "- **Promotion ID**: \`${{ needs.commit-analysis.outputs.promotion_id }}\`"
            echo "- **Timestamp**: ${{ needs.commit-analysis.outputs.timestamp }}"
            echo "- **Commit Count**: ${{ needs.commit-analysis.outputs.commit_count }} commits"
            echo "- **Source**: \`develop\`"
            echo "- **Target**: \`staging\`"
            echo "- **Triggered By**: @${{ github.actor }} via manual workflow dispatch"
            echo ""

            if [ -n "${{ needs.commit-analysis.outputs.feature_prs_md }}" ]; then
              echo "### üîó Feature PRs"
              echo "${{ needs.commit-analysis.outputs.feature_prs_md }}"
              echo ""
            fi

            echo "### üìù Features to be Deployed"
            echo "#### üß© Commits Grouped by Feature"
            echo "${{ needs.commit-analysis.outputs.grouped_commits_md }}"
            echo ""

            echo "### üîÑ What Happens on Merge"
            echo "1. This PR branch contains one commit per feature group"
            echo "2. Merge with \"Create a merge commit\" or \"Rebase and merge\" to preserve grouped commits"
            echo "3. Staging deployment will be triggered"
            echo "4. Changes will be available for testing in staging environment"
            echo ""

            echo "### ‚úÖ Pre-merge Checklist"
            echo "- [ ] Code review complete"
            echo "- [ ] All tests passing on develop"
            echo "- [ ] No breaking changes without migration plan"
            echo "- [ ] Ready for QA testing"
            echo ""
            echo "---"
            echo "üîç This will deploy to **STAGING** environment for testing."
            echo ""
            echo "üë• Reviewers: @rahulcheryala"
          } > "$BODY_FILE"

          echo "üîé Checking for existing open PR from promoter branch ‚Üí staging..."
          EXISTING_NUMBER="$(gh pr list --base staging --head "$HEAD_BRANCH" --state open --json number --jq '.[0].number' || true)"
          BODY_TEXT="$(cat "$BODY_FILE")"
          if [ -n "${EXISTING_NUMBER:-}" ] && [ "${EXISTING_NUMBER}" != "null" ]; then
            PR_NUMBER="$EXISTING_NUMBER"
            echo "üîÅ Reusing PR #$PR_NUMBER and updating title/body via API..."
            gh api -X PATCH "repos/${REPO}/pulls/${PR_NUMBER}" -f title="$TITLE" -f body="$BODY_TEXT" >/dev/null
          else
            echo "üÜï Creating PR base=staging head=$HEAD_BRANCH via API..."
            PR_NUMBER="$(gh api -X POST "repos/${REPO}/pulls" \
              -f title="$TITLE" \
              -f head="$HEAD_BRANCH" \
              -f base="staging" \
              -f body="$BODY_TEXT" \
              --jq .number)"
          fi

          PR_URL="https://github.com/${REPO}/pull/${PR_NUMBER}"

          echo "üè∑Ô∏è Adding labels and requesting reviewers..."
          printf '{"labels":["staging","deployment","promotion","auto-generated"]}\n' > labels.json
          gh api -X POST "repos/${REPO}/issues/${PR_NUMBER}/labels" --input labels.json >/dev/null || true
          printf '{"reviewers":["rahulcheryala"]}\n' > reviewers.json
          gh api -X POST "repos/${REPO}/pulls/${PR_NUMBER}/requested_reviewers" --input reviewers.json >/dev/null || true

          echo "pr_number=$PR_NUMBER" >> "$GITHUB_OUTPUT"
          echo "pr_url=$PR_URL" >> "$GITHUB_OUTPUT"
          echo "üîó PR Link: $PR_URL"

  workflow-summary:
    name: Workflow Summary
    runs-on: ubuntu-latest
    needs: [commit-analysis, create-pr]
    if: always() && needs.commit-analysis.outputs.promotion_needed == 'true'
    steps:
      - name: Display workflow summary
        run: |
          echo ""
          echo "================================================"
          echo "üöÄ STAGING PROMOTION WORKFLOW COMPLETED"
          echo "================================================"
          echo ""
          echo "‚úÖ Analysis complete"
          if [ "${{ needs.create-pr.result }}" = "success" ]; then
            echo "‚úÖ PR created/updated"
          else
            echo "‚ö†Ô∏è PR not created (skipped or failed)"
          fi
          echo ""
          echo "üìã Promotion Details:"
          echo "  ‚Ä¢ Promotion ID: ${{ needs.commit-analysis.outputs.promotion_id }}"
          echo "  ‚Ä¢ Timestamp: ${{ needs.commit-analysis.outputs.timestamp }}"
          echo "  ‚Ä¢ Commit Count: ${{ needs.commit-analysis.outputs.commit_count }}"
          echo "  ‚Ä¢ PR Number: ${{ needs.create-pr.outputs.pr_number }}"
          echo ""
          echo "üîó PR Link: ${{ needs.create-pr.outputs.pr_url }}"
          echo "üß™ Reminder: Merging deploys to STAGING for testing."
          echo ""
